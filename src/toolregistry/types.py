from typing import Literal, Optional, Union, overload

from pydantic import BaseModel


class Function(BaseModel):
    arguments: str
    """
    The arguments to call the function with, as generated by the model in JSON
    format. Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """

    name: str
    """The name of the function to call."""


class ChatCompletionMessageToolCall(BaseModel):
    """
    Example usage

    {
        "id": "call_12345xyz",
        "type": "function",
        "function": {
            "name": "get_weather",
            "arguments": "{\"location\":\"Paris, France\"}"
        }
    }
    """

    id: str
    """The ID of the tool call."""

    function: Function
    """The function that the model called."""

    type: Literal["function"] = "function"
    """The type of the tool. Currently, only `function` is supported."""

class ChatCompetionMessageToolCallResult(BaseModel):
    """
    Example usage

    {
        "role": "tool",
        "tool_call_id": tool_call.id,
        "content": str(result)
    }
    """

    role: Literal["tool"] = "tool"
    """The role of the message. Always `tool`."""

    tool_call_id: str
    """The ID of the tool call that this message is responding to."""

    content: str
    """Result of the tool call in string format."""


class ResponseFunctionToolCall(BaseModel):
    """
    Example usage

    {
        "id": "fc_12345xyz",
        "call_id": "call_12345xyz",
        "type": "function_call",
        "name": "get_weather",
        "arguments": "{\"location\":\"Paris, France\"}"
    }
    """

    arguments: str
    """A JSON string of the arguments to pass to the function."""

    call_id: str
    """The unique ID of the function tool call generated by the model."""

    name: str
    """The name of the function to run."""

    type: Literal["function_call"] = "function_call"
    """The type of the function tool call. Always `function_call`."""

    id: Optional[str] = None
    """The unique ID of the function tool call."""

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None
    """The status of the item.

    One of `in_progress`, `completed`, or `incomplete`. Populated when items are
    returned via API.
    """

class ResponseFunctionToolCallResult(BaseModel):
    """
    Example usage

    {
        "type": "function_call_output",
        "call_id": tool_call.call_id,
        "output": str(result)
    }
    """

    type: Literal["function_call_output"] = "function_call_output"
    """The type of the function tool call result. Always `function_call_output`."""

    call_id: str
    """The unique ID of the function tool call."""

    output: str
    """The output of the function tool call as a string."""


@overload
def convert_to_chat_completion(
    response_call: ChatCompletionMessageToolCall,
) -> ChatCompletionMessageToolCall: ...


@overload
def convert_to_chat_completion(
    response_call: ResponseFunctionToolCall,
) -> ChatCompletionMessageToolCall: ...


def convert_to_chat_completion(
    response_call: Union[
        ChatCompletionMessageToolCall,
        ResponseFunctionToolCall,
    ],
) -> ChatCompletionMessageToolCall:
    """Convert ResponseFunctionToolCall to ChatCompletionMessageToolCall format."""
    if isinstance(response_call, ChatCompletionMessageToolCall):
        return response_call

    if isinstance(response_call, ResponseFunctionToolCall):
        return ChatCompletionMessageToolCall(
            id=response_call.call_id,
            function=Function(
                name=response_call.name, arguments=response_call.arguments
            ),
        )

    raise TypeError("Unsupported type for conversion")
